<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas To TangLiang</title>
    <!-- Use Tailwind CSS for quick styling (optional, but good for layout) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MediaPipe Dependencies (Global Scripts) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js Dependencies (Global Scripts - version 0.115.0 to match original shaders) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <style>
        body {
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #c5a880;
            user-select: none;
        }

        #three-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .input_video {
            display: none;
        }

        /* Modal Styles */
        #start-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .modal-content {
            background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #c5a880;
            box-shadow: 0 0 30px rgba(197, 168, 128, 0.3);
            text-align: center;
            max-width: 90%;
            width: 400px;
        }

        /* Text Styles */
        #christmas-text {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Brush Script MT', cursive;
            font-size: 3rem;
            background: linear-gradient(to bottom, #fff, #c5a880);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(197, 168, 128, 0.5);
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            text-align: center;
            width: 100%;
            white-space: nowrap;
            transition: all 3s ease-in-out;
        }

        #christmas-text.visible {
            opacity: 1;
            transform: translate(-50%, -50%);
        }

        .loading {
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        /* Gesture Guide */
        .gesture-guide {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 50;
            font-size: 14px;
            line-height: 1.8;
            color: rgba(197, 168, 128, 0.9);
            text-align: right;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            font-family: "Microsoft YaHei", sans-serif;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 2s ease-out, transform 2s ease-out;
        }

        .gesture-guide.visible {
            opacity: 1;
            transform: translateY(0);
        }

        @media (max-width: 600px) {
            .modal-content { width: 90%; padding: 20px; }
            #christmas-text { font-size: 1.8rem; top: 12%; white-space: normal; line-height: 1.2; }
            .gesture-guide { bottom: 20px; right: 20px; font-size: 12px; }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "three": "https://esm.sh/three@^0.182.0",
    "three/": "https://esm.sh/three@^0.182.0/",
    "@mediapipe/hands": "https://esm.sh/@mediapipe/hands@^0.4.1675469240",
    "@mediapipe/camera_utils": "https://esm.sh/@mediapipe/camera_utils@^0.3.1675466862"
  }
}
</script>
</head>
<body>
    <!-- Hidden video element for MediaPipe -->
    <video class="input_video"></video>
    
    <div class="loading">Âä†ËΩΩËµÑÊ∫ê‰∏≠...</div>
    <canvas id="three-canvas"></canvas>

    <!-- Gesture Guide UI -->
    <div class="gesture-guide" id="gesture-guide">
        <div class="flex items-center justify-end gap-2"><span>‚úã Êï£ÂºÄ¬∑Êº´Â§©ÊòüÊ≤≥</span></div>
        <div class="flex items-center justify-end gap-2"><span>‚úåÔ∏è ÂáùËÅö¬∑Áà±ÂøÉ</span></div>
        <div class="flex items-center justify-end gap-2"><span>‚úä ËøòÂéü¬∑Âú£ËØûÊ†ë</span></div>
    </div>

    <!-- Start Modal -->
    <div id="start-modal">
        <div class="modal-content">
            <div class="text-3xl text-[#c5a880] mb-5 font-bold">üéÅ Âú£ËØûÁ§ºÁâ©</div>
            <p class="text-lg text-[#ccc] mb-8">
                ÂèÆÂíöÔºÅTangLiang‰Ω†Êúâ‰∏Ä‰ªΩÊù•Ëá™Âú£ËØûËÄÅ‰∫∫ÁöÑ‰∏ìÂ±ûÁ§ºÁâ©ÔºåÊòØÂê¶Êü•Êî∂Ôºü
            </p>
            <div class="flex justify-around gap-5 relative">
                <button class="px-8 py-3 rounded-full text-base cursor-pointer font-bold outline-none bg-[#333] text-[#888] border border-[#555] transition-transform duration-300" id="btn-no">
                    ‰ø∫‰∏ç‰∏≠ÂòûÔºåÁÇπÂè≥Ëæπ
                </button>
                <button class="px-8 py-3 rounded-full text-base cursor-pointer font-bold outline-none bg-gradient-to-r from-[#d4af37] to-[#c5a880] text-black shadow-[0_0_15px_rgba(212,175,55,0.5)] hover:scale-105 hover:shadow-[0_0_25px_rgba(212,175,55,0.8)]" id="btn-yes">
                    Âì¶Ë±ÅÔºåÂºÄÂøÉÊî∂‰∏ã
                </button>
            </div>
        </div>
    </div>

    <div id="christmas-text">Merry Christmas To You~</div>

    <audio id="christmas-music" loop>
        <source src="https://music.163.com/song/media/outer/url?id=2153919351.mp3" type="audio/mpeg">
        ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÈü≥È¢ëÂÖÉÁ¥†„ÄÇ
    </audio>

    <script>
        // --- 1. Audio FX System ---
        const AudioFX = {
            ctx: null,
            gainNode: null,
            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.gainNode = this.ctx.createGain();
                    this.gainNode.gain.value = 0.4;
                    this.gainNode.connect(this.ctx.destination);
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function(freq, type, duration, delay = 0) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + delay);
                gain.gain.setValueAtTime(0, this.ctx.currentTime + delay);
                gain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + delay + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + duration);
                osc.connect(gain);
                gain.connect(this.gainNode);
                osc.start(this.ctx.currentTime + delay);
                osc.stop(this.ctx.currentTime + delay + duration + 0.5);
            },
            playScatter: function() {
                this.init();
                for(let i=0; i<8; i++) {
                    this.playTone(800 + Math.random() * 1200, 'sine', 0.8, i * 0.04);
                }
            },
            playHeart: function() {
                this.init();
                this.playTone(261.63, 'sine', 1.5);
                this.playTone(329.63, 'sine', 1.5, 0.1);
                this.playTone(392.00, 'sine', 1.5, 0.2);
                this.playTone(523.25, 'sine', 2.0, 0.3);
            },
            playTree: function() {
                this.init();
                this.playTone(200, 'triangle', 0.6);
                this.playTone(100, 'sine', 0.8, 0.1);
            }
        };

        // --- 2. Main Logic ---
        let threeRenderer, threeScene, threeCamera, composer;
        let targetState = 'tree';
        let currentState = { heartMix: 0, explodeMix: 0 };
        let lastState = 'tree';

        const uniforms = {
            time: { type: "f", value: 0.0 },
            step: { type: "f", value: 0.0 },
            flash: { type: "f", value: 0.0 },
            uHeartMix: { type: "f", value: 0.0 },
            uExplodeMix: { type: "f", value: 0.0 }
        };

        const params = {
            bloomStrength: 1.8,
            bloomThreshold: 0,
            bloomRadius: 0.6
        };

        // Initialize when window loads
        window.addEventListener('load', init);

        function init() {
            initThreeJS();
            // Hide loading text once ThreeJS is ready, HandTracking will load async
            document.querySelector('.loading').style.display = 'none';
        }

        // --- 3. Three.js Setup ---
        function initThreeJS() {
            const canvas = document.getElementById('three-canvas');

            threeScene = new THREE.Scene();
            threeScene.fog = new THREE.FogExp2(0x050505, 0.002);

            threeRenderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            threeRenderer.setPixelRatio(window.devicePixelRatio);
            threeRenderer.setSize(window.innerWidth, window.innerHeight);
            // Use legacy encodings for 0.115.0 compatibility
            threeRenderer.toneMapping = THREE.ReinhardToneMapping;
            
            threeCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            threeCamera.position.set(-0.1, -2.5, 25);
            threeCamera.rotation.set(0.1, 0, 0);

            addPlane(threeScene, uniforms, 3000);
            addSnow(threeScene, uniforms);

            for (let i = 0; i < 5; i++) {
                addTree(threeScene, uniforms, 4000, [0, 0, -20 * i]);
            }

            const renderScene = new THREE.RenderPass(threeScene, threeCamera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = params.bloomThreshold;
            bloomPass.strength = params.bloomStrength;
            bloomPass.radius = params.bloomRadius;

            composer = new THREE.EffectComposer(threeRenderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            
            animateThreeJS();
            
            // Handle Resize
            window.addEventListener('resize', () => {
                threeCamera.aspect = window.innerWidth / window.innerHeight;
                threeCamera.updateProjectionMatrix();
                threeRenderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        let step = 0;
        let flashState = 0;
        let flashStartTime = 0;
        const flashDuration = 3000;

        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        function animateThreeJS(currentTime = 0) {
            uniforms.time.value = currentTime;
            uniforms.step.value = step;
            
            const flashIntensity = calculateNaturalFlash(currentTime);
            uniforms.flash.value = flashIntensity;

            let tHeart = (targetState === 'heart') ? 1.0 : 0.0;
            let tExplode = (targetState === 'explode') ? 1.0 : 0.0;

            if(targetState === 'heart') tExplode = 0;
            if(targetState === 'explode') tHeart = 0;

            currentState.heartMix = lerp(currentState.heartMix, tHeart, 0.04);
            currentState.explodeMix = lerp(currentState.explodeMix, tExplode, 0.06);

            uniforms.uHeartMix.value = currentState.heartMix;
            uniforms.uExplodeMix.value = currentState.explodeMix;

            const bloomPass = composer.passes[1];
            let extraBloom = currentState.explodeMix * 1.5;
            bloomPass.strength = params.bloomStrength * (0.8 + flashIntensity * 0.4) + extraBloom;

            step = (step + 1) % 1000;
            composer.render();
            requestAnimationFrame(animateThreeJS);
        }

        function calculateNaturalFlash(currentTime) {
            if (flashStartTime === 0 || currentTime - flashStartTime > flashDuration) {
                if (Math.random() > 0.5 || flashStartTime === 0) {
                    flashState = flashState === 0 ? 1 : 0;
                    flashStartTime = currentTime;
                }
            }
            const progress = Math.min((currentTime - flashStartTime) / (flashDuration / 2), 1);
            if (flashState === 0) {
                return 1 - progress * progress;
            } else {
                return progress * progress;
            }
        }

        // --- 4. Shaders & Geometry Construction ---
        // Functions: rand, map, polar
        const rand = (max, min = 0) => min + Math.random() * (max - min);
        const map = (value, sMin, sMax, dMin, dMax) => dMin + (value - sMin) / (sMax - sMin) * (dMax - dMin);
        const polar = (ang, r = 1) => [r * Math.cos(ang), r * Math.sin(ang)];
        const TAU = 2 * Math.PI;

        function addTree(scene, uniforms, totalPoints, treePosition) {
            const vertexShader = `
                attribute float mIndex;
                attribute vec3 heartPos;
                attribute vec3 explodePos;
                varying vec3 vColor;
                varying float opacity;
                uniform float flash;
                uniform float uHeartMix;
                uniform float uExplodeMix;

                float norm(float value, float min, float max ){ return (value - min) / (max - min); }
                float lerp(float norm, float min, float max){ return (max - min) * norm + min; }
                float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){ return lerp(norm(value, sourceMin, sourceMax), destMin, destMax); }

                void main() {
                    vColor = color;
                    vec3 p = position;
                    vec3 mixedPos = mix(p, heartPos, uHeartMix);
                    mixedPos = mix(mixedPos, explodePos, uExplodeMix);
                    vec4 mvPosition = modelViewMatrix * vec4( mixedPos, 1.0 );
                    
                    float sizeStateBoost = 1.0 + uHeartMix * 2.0 + uExplodeMix * 4.0;
                    float sizeMultiplier = mix(0.8, 1.2, flash) * sizeStateBoost;
                    
                    opacity = map(mvPosition.z , -200.0, 15.0, 0.0, 1.0);
                    gl_PointSize = sizeMultiplier * ( 100.0 / -mvPosition.z );
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            const fragmentShader = `
                varying vec3 vColor;
                varying float opacity;
                uniform sampler2D pointTexture;
                uniform float flash;
                uniform float uExplodeMix;

                void main() {
                    float brightness = mix(0.7, 1.3, flash) + uExplodeMix * 0.8;
                    vec3 color = vColor * brightness;
                    float dist = length(gl_PointCoord.xy - 0.5);
                    float glow = smoothstep(0.5, 0.4, dist) * 0.3;
                    gl_FragColor = vec4( color + glow, opacity );
                    gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                }
            `;

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    ...uniforms,
                    pointTexture: { value: new THREE.TextureLoader().load(`https://assets.codepen.io/3685267/spark1.png`) }
                },
                vertexShader,
                fragmentShader,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            });

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const phases = [];
            const mIndexs = [];
            const heartPositions = [];
            const explodePositions = [];
            const color = new THREE.Color();
            const [px, py, pz] = treePosition;

            for (let i = 0; i < totalPoints; i++) {
                // Tree
                const t = Math.random();
                const y = map(t, 0, 1, -8, 10);
                const ang = map(t, 0, 1, 0, 6 * TAU) + TAU / 2 * (i % 2);
                const [z, x] = polar(ang, map(t, 0, 1, 5, 0));
                const modifier = map(t, 0, 1, 1, 0);
                positions.push(x + rand(-0.3, 0.3) + px, y + rand(-0.3, 0.3) + py, z + rand(-0.3, 0.3) + pz);

                // Heart
                const ht = Math.random() * TAU;
                const scaleH = 0.4;
                const hx = 16 * Math.pow(Math.sin(ht), 3) * scaleH;
                const hy = (13 * Math.cos(ht) - 5 * Math.cos(2*ht) - 2 * Math.cos(3*ht) - Math.cos(4*ht)) * scaleH;
                heartPositions.push(hx, hy + 2, (Math.random() - 0.5) * 5 - 10);

                // Explode
                const r = 60 * Math.pow(Math.random(), 0.5);
                const theta = Math.random() * TAU;
                const phi = Math.acos(2 * Math.random() - 1);
                explodePositions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi) - 20
                );

                // Color
                const colorSeed = Math.random();
                if (colorSeed > 0.8) color.setHex(0xff0000);
                else if (colorSeed > 0.5) color.setHex(0x00ff00);
                else color.setHSL(map(i, 0, totalPoints, 0.1, 0.2), 1.0, 0.6);
                colors.push(color.r, color.g, color.b);
                phases.push(rand(1000));
                sizes.push(1);
                mIndexs.push(map(i, 0, totalPoints, 1.0, 0.0));
            }

            geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute("heartPos", new THREE.Float32BufferAttribute(heartPositions, 3));
            geometry.setAttribute("explodePos", new THREE.Float32BufferAttribute(explodePositions, 3));
            geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
            geometry.setAttribute("mIndex", new THREE.Float32BufferAttribute(mIndexs, 1));

            const tree = new THREE.Points(geometry, shaderMaterial);
            scene.add(tree);
        }

        function addSnow(scene, uniforms) {
            const vertexShader = `
                attribute float size;
                attribute float phase;
                attribute float phaseSecondary;
                varying vec3 vColor;
                varying float opacity;
                uniform float time;
                uniform float step;
                float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){ return destMin + (value - sourceMin) / (sourceMax - sourceMin) * (destMax - destMin); }
                void main() {
                    float t = time* 0.0006;
                    vColor = color;
                    vec3 p = position;
                    p.y = map(mod(phase+step, 1000.0), 0.0, 1000.0, 25.0, -8.0);
                    p.x += sin(t+phase);
                    p.z += sin(t+phaseSecondary);
                    opacity = map(p.z, -150.0, 15.0, 0.0, 1.0);
                    vec4 mvPosition = modelViewMatrix * vec4( p, 1.0 );
                    gl_PointSize = size * ( 100.0 / -mvPosition.z );
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            const fragmentShader = `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                varying float opacity;
                void main() {
                    gl_FragColor = vec4( vColor, opacity );
                    gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                }
            `;

            const snowSprites = [
                "https://assets.codepen.io/3685267/snowflake1.png",
                "https://assets.codepen.io/3685267/snowflake2.png",
                "https://assets.codepen.io/3685267/snowflake3.png",
                "https://assets.codepen.io/3685267/snowflake4.png",
                "https://assets.codepen.io/3685267/snowflake5.png"
            ];

            snowSprites.forEach(sprite => {
                const totalPoints = 300;
                const shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: { ...uniforms, pointTexture: { value: new THREE.TextureLoader().load(sprite) } },
                    vertexShader, fragmentShader,
                    blending: THREE.AdditiveBlending, depthTest: false, transparent: true, vertexColors: true
                });
                const geometry = new THREE.BufferGeometry();
                const positions = [], colors = [], sizes = [], phases = [], phaseSecondaries = [];
                const color = new THREE.Color();
                for (let i = 0; i < totalPoints; i++) {
                    positions.push(rand(25, -25), 0, rand(15, -150));
                    color.setHSL(0.6, 0.1, 0.9);
                    colors.push(color.r, color.g, color.b);
                    phases.push(rand(1000));
                    phaseSecondaries.push(rand(1000));
                    sizes.push(rand(4, 2));
                }
                geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
                geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
                geometry.setAttribute("phaseSecondary", new THREE.Float32BufferAttribute(phaseSecondaries, 1));
                scene.add(new THREE.Points(geometry, shaderMaterial));
            });
        }

        function addPlane(scene, uniforms, totalPoints) {
            const vertexShader = `
                attribute float size;
                attribute vec3 customColor;
                varying vec3 vColor;
                uniform float flash;
                void main() {
                    vColor = customColor * mix(0.95, 1.05, flash - 0.9);
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                    gl_PointSize = size * ( 300.0 / -mvPosition.z );
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            const fragmentShader = `
                varying vec3 vColor;
                void main() {
                    float dist = length(gl_PointCoord.xy - 0.5);
                    float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                    float glow = smoothstep(0.5, 0.0, dist) * 0.2;
                    gl_FragColor = vec4(vColor + glow, alpha * 0.8);
                }
            `;
            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms, vertexShader, fragmentShader,
                blending: THREE.AdditiveBlending, depthTest: false, transparent: true, vertexColors: true
            });
            const geometry = new THREE.BufferGeometry();
            const positions = [], colors = [], sizes = [];
            const color = new THREE.Color();
            for (let i = 0; i < totalPoints; i++) {
                positions.push(rand(-50, 50), 0, rand(-150, 15));
                color.setHSL(map(i, 0, totalPoints, 0.5, 0.7), 0.9, 0.4);
                colors.push(color.r, color.g, color.b);
                sizes.push(1.5);
            }
            geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute("customColor", new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
            const plane = new THREE.Points(geometry, shaderMaterial);
            plane.position.y = -8;
            scene.add(plane);
        }

        // --- 5. UI & Interaction Logic ---
        const modal = document.getElementById('start-modal');
        const btnYes = document.getElementById('btn-yes');
        const btnNo = document.getElementById('btn-no');
        const textOverlay = document.getElementById('christmas-text');
        const gestureGuide = document.getElementById('gesture-guide');
        const christmasMusic = document.getElementById('christmas-music');

        btnNo.addEventListener('mouseenter', () => {
            if(window.innerWidth < 768) return;
            const x = Math.random() * 300 - 50;
            const y = Math.random() * 200 - 50;
            btnNo.style.transform = `translate(${x}px, ${y}px)`;
        });

        btnNo.addEventListener('click', () => {
            alert("È™ó‰Ω†ÁöÑÔºåÂÖ∂ÂÆûÁÇπ‰∫Ü‰πüÊ≤°Áî®ÔºÅüéÑüéÑüéÑ");
        });

        btnYes.addEventListener('click', () => {
            modal.style.opacity = '0';
            // Start audio on user gesture
            christmasMusic.play().catch(e => console.log("Auto-play blocked:", e));
            AudioFX.init();

            setTimeout(() => {
                modal.style.display = 'none';
                textOverlay.classList.add('visible');
                gestureGuide.classList.add('visible');
                // Start Hand Tracking
                initHandTracking();
            }, 1000);
        });

        // --- 6. Hand Tracking Logic ---
        function initHandTracking() {
            const videoElement = document.querySelector(".input_video");
            
            // Safe check if MediaPipe is loaded
            if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                console.error("MediaPipe libraries not loaded. Check internet connection.");
                return;
            }

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            camera.start().catch(e => console.error("Camera start failed:", e));
        }

        function onResults(results) {
            let newState = 'tree';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                const isThumbUp = landmarks[4].y < landmarks[3].y;
                const isIndexUp = landmarks[8].y < landmarks[6].y;
                const isMiddleUp = landmarks[12].y < landmarks[10].y;
                const isRingUp = landmarks[16].y < landmarks[14].y;
                const isPinkyUp = landmarks[20].y < landmarks[18].y;

                const fingersUp = [isIndexUp, isMiddleUp, isRingUp, isPinkyUp].filter(Boolean).length;

                // ‚úã Open palm / Explode
                if (fingersUp >= 4) {
                    newState = 'explode';
                }
                // ‚úåÔ∏è Peace/Victory -> Heart shape (index + middle)
                else if (isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp) {
                    newState = 'heart';
                }
                // ‚úä Fist / Default -> Tree
                else {
                    newState = 'tree';
                }
            } else {
                newState = 'tree';
            }

            if (newState !== lastState) {
                targetState = newState;
                if (newState === 'explode') AudioFX.playScatter();
                if (newState === 'heart') AudioFX.playHeart();
                if (newState === 'tree' && lastState !== 'tree') AudioFX.playTree();
                lastState = newState;
            }
        }
    </script>
</body>
</html>