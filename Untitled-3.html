<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Merry Christmas To TangLiang</title>
  <!-- å¼•å…¥ MediaPipe åº“ -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      background: #050505;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #c5a880;
    }

    #three-canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* éšè—æ‘„åƒå¤´ç”»é¢ï¼Œåªç”¨äºæ•æ‰ */
    .input_video {
      display: none;
    }

    #start-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 1s ease;
    }

    .modal-content {
      background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
      padding: 40px;
      border-radius: 20px;
      border: 2px solid #c5a880;
      box-shadow: 0 0 30px rgba(197, 168, 128, 0.3);
      text-align: center;
      max-width: 90%;
      width: 400px;
    }

    .modal-title {
      font-size: 2rem;
      color: #c5a880;
      margin-bottom: 20px;
      font-weight: bold;
    }

    .modal-text {
      font-size: 1.1rem;
      color: #ccc;
      margin-bottom: 30px;
    }

    .btn-group {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      position: relative;
    }

    .btn {
      padding: 12px 30px;
      border: none;
      border-radius: 50px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      outline: none;
    }

    .btn-accept {
      background: linear-gradient(45deg, #d4af37, #c5a880);
      color: #000;
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
    }

    .btn-accept:hover {
      transform: scale(1.05);
      box-shadow: 0 0 25px rgba(212, 175, 55, 0.8);
    }

    .btn-reject {
      background: #333;
      color: #888;
      border: 1px solid #555;
    }

    #christmas-text {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Brush Script MT', cursive;
      font-size: 3rem; 
      background: linear-gradient(to bottom, #fff, #c5a880);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px rgba(197, 168, 128, 0.5);
      z-index: 10;
      opacity: 0;
      pointer-events: none;
      text-align: center;
      width: 100%;
      white-space: nowrap; 
    }

    .fade-in {
      animation: fadeInText 3s forwards ease-in-out;
      animation-delay: 1s;
    }

    @keyframes fadeInText {
      0% { opacity: 0; transform: translate(-50%, -30%); }
      100% { opacity: 1; transform: translate(-50%, -50%); }
    }

    .loading {
      color: white;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
    }
    
    /* å³ä¸‹è§’æ‰‹åŠ¿æç¤ºæ ·å¼ */
    .gesture-guide {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 50;
      font-size: 14px;
      line-height: 1.8;
      color: rgba(197, 168, 128, 0.9);
      text-align: right;
      pointer-events: none;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
      font-family: "Microsoft YaHei", sans-serif;
      animation: guideFadeIn 2s ease-out 2s forwards;
      opacity: 0;
    }

    .gesture-item {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .gesture-icon {
      font-size: 18px;
    }

    @keyframes guideFadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 600px) {
      .modal-content { width: 90%; padding: 20px; }
      .modal-title { font-size: 1.5rem; }
      #christmas-text { font-size: 1.8rem; top: 12%; white-space: normal; line-height: 1.2; }
      .gesture-guide { bottom: 20px; right: 20px; font-size: 12px; }
    }
  </style>
</head>

<body>
  <!-- æ‘„åƒå¤´è§†é¢‘æµå®¹å™¨ -->
  <video class="input_video"></video>

  <div class="loading">åŠ è½½ä¸­...</div>
  <canvas id="three-canvas"></canvas>
  
  <!-- æ‰‹åŠ¿æç¤º UI -->
  <div class="gesture-guide" id="gesture-guide">
    <div class="gesture-item"><span>âœ‹ æ•£å¼€Â·æ¼«å¤©æ˜Ÿæ²³</span></div>
    <div class="gesture-item"><span>âœŒï¸ å‡èšÂ·çˆ±å¿ƒ</span></div>
    <div class="gesture-item"><span>âœŠ è¿˜åŸÂ·åœ£è¯æ ‘</span></div>
  </div>

  <div id="start-modal">
    <div class="modal-content">
      <div class="modal-title">ğŸ åœ£è¯ç¤¼ç‰©</div>
      <p class="modal-text">å®å’šï¼TangLiangä½ æœ‰ä¸€ä»½æ¥è‡ªåœ£è¯è€äººçš„ä¸“å±ç¤¼ç‰©ï¼Œæ˜¯å¦æŸ¥æ”¶ï¼Ÿ</p>
      <div class="btn-group" id="btn-container">
        <button class="btn btn-reject" id="btn-no">ä¿ºä¸ä¸­å˜ï¼Œç‚¹å³è¾¹</button>
        <button class="btn btn-accept" id="btn-yes">å“¦è±ï¼Œå¼€å¿ƒæ”¶ä¸‹</button>
      </div>
    </div>
  </div>

  <div id="christmas-text">Merry Christmas To You~</div>
  
  <audio id="christmas-music" loop>
    <source src="https://music.163.com/song/media/outer/url?id=2153919351.mp3" type="audio/mpeg">
    æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
  </audio>

  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <script>
    // --- äº¤äº’éŸ³æ•ˆç³»ç»Ÿ ---
    const AudioFX = {
      ctx: null,
      gainNode: null,
      init: function() {
        if (!this.ctx) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.ctx = new AudioContext();
          this.gainNode = this.ctx.createGain();
          this.gainNode.gain.value = 0.4; // éŸ³æ•ˆç»Ÿä¸€éŸ³é‡
          this.gainNode.connect(this.ctx.destination);
        }
        if (this.ctx.state === 'suspended') {
          this.ctx.resume();
        }
      },
      playTone: function(freq, type, duration, delay = 0) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime + delay);
        
        // éŸ³é‡åŒ…ç»œï¼Œé˜²æ­¢çˆ†éŸ³
        gain.gain.setValueAtTime(0, this.ctx.currentTime + delay);
        gain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + delay + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + duration);
        
        osc.connect(gain);
        gain.connect(this.gainNode);
        osc.start(this.ctx.currentTime + delay);
        osc.stop(this.ctx.currentTime + delay + duration + 0.5);
      },
      playScatter: function() {
        this.init();
        // æ¢¦å¹»çš„é£é“ƒå£°/æ˜Ÿç©ºå£°
        for(let i=0; i<8; i++) {
          this.playTone(800 + Math.random() * 1200, 'sine', 0.8, i * 0.04);
        }
      },
      playHeart: function() {
        this.init();
        // æ¸©æš–çš„å’Œå¼¦
        this.playTone(261.63, 'sine', 1.5); // C4
        this.playTone(329.63, 'sine', 1.5, 0.1); // E4
        this.playTone(392.00, 'sine', 1.5, 0.2); // G4
        this.playTone(523.25, 'sine', 2.0, 0.3); // C5
      },
      playTree: function() {
        this.init();
        // èšæ‹¢çš„ä½æ²‰éŸ³æ•ˆ
        this.playTone(200, 'triangle', 0.6);
        this.playTone(100, 'sine', 0.8, 0.1);
      }
    };

    let threeRenderer, threeScene, threeCamera, composer;
    
    // çŠ¶æ€ç®¡ç†
    let targetState = 'tree'; 
    let currentState = { heartMix: 0, explodeMix: 0 };
    let lastState = 'tree';

    const uniforms = {
      time: { type: "f", value: 0.0 },
      step: { type: "f", value: 0.0 },
      flash: { type: "f", value: 0.0 },
      tAudioData: { value: new THREE.DataTexture(new Uint8Array(128), 64, 1, THREE.LuminanceFormat) },
      // å˜å½¢æ··åˆå› å­
      uHeartMix: { type: "f", value: 0.0 },
      uExplodeMix: { type: "f", value: 0.0 }
    };

    const params = {
      exposure: 1,
      bloomStrength: 1.8,
      bloomThreshold: 0,
      bloomRadius: 0.6
    };

    function init() {
      initThreeJS();
      initHandTracking();
      document.querySelector('.loading').style.display = 'none';
    }

    function initThreeJS() {
      const canvas = document.getElementById('three-canvas');

      threeScene = new THREE.Scene();
      threeScene.fog = new THREE.FogExp2(0x050505, 0.002);

      threeRenderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
      });
      threeRenderer.setPixelRatio(window.devicePixelRatio);
      threeRenderer.setSize(window.innerWidth, window.innerHeight);
      threeRenderer.toneMapping = THREE.ReinhardToneMapping;
      threeRenderer.outputEncoding = THREE.sRGBEncoding;
      threeCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
      threeCamera.position.set(-0.1, -2.5, 25);
      threeCamera.rotation.set(0.1, 0, 0);
      
      addPlane(threeScene, uniforms, 3000);
      addSnow(threeScene, uniforms);

      // åˆ›å»ºäº”å±‚åœ£è¯æ ‘
      for (let i = 0; i < 5; i++) {
        // ä¼ å…¥å›¾å±‚ç´¢å¼•ï¼Œç”¨äºè®¡ç®—ä½ç½®
        addTree(threeScene, uniforms, 4000, [0, 0, -20 * i], i);
      }

      const renderScene = new THREE.RenderPass(threeScene, threeCamera);
      const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, 0.4, 0.85
      );
      bloomPass.threshold = params.bloomThreshold;
      bloomPass.strength = params.bloomStrength;
      bloomPass.radius = params.bloomRadius;

      composer = new THREE.EffectComposer(threeRenderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);
      animateThreeJS();
    }

    let step = 0;
    let flashState = 0;
    let flashIntensity = 0;
    let flashStartTime = 0;
    const flashDuration = 3000;
    const TAU = 2 * Math.PI;

    // çº¿æ€§æ’å€¼å‡½æ•°
    function lerp(start, end, amt) {
      return (1 - amt) * start + amt * end;
    }

    function animateThreeJS(currentTime = 0) {
      if (!threeRenderer) return;
      uniforms.time.value = currentTime;
      uniforms.step.value = step;
      flashIntensity = calculateNaturalFlash(currentTime);
      uniforms.flash.value = flashIntensity;

      // å¹³æ»‘æ›´æ–°çŠ¶æ€æ··åˆå€¼
      let tHeart = (targetState === 'heart') ? 1.0 : 0.0;
      let tExplode = (targetState === 'explode') ? 1.0 : 0.0;

      // äº’æ–¥é€»è¾‘ç¡®ä¿è¿‡æ¸¡å¹²å‡€
      if(targetState === 'heart') tExplode = 0;
      if(targetState === 'explode') tHeart = 0;

      // è°ƒæ•´è¿‡æ¸¡é€Ÿåº¦ï¼Œæ•£å¼€ç¨å¾®å¿«ä¸€ç‚¹
      currentState.heartMix = lerp(currentState.heartMix, tHeart, 0.04);
      currentState.explodeMix = lerp(currentState.explodeMix, tExplode, 0.06);

      uniforms.uHeartMix.value = currentState.heartMix;
      uniforms.uExplodeMix.value = currentState.explodeMix;

      const bloomPass = composer.passes[1];
      // çˆ†ç‚¸æ—¶å¢åŠ å…‰æ™•å¼ºåº¦
      let extraBloom = currentState.explodeMix * 1.5;
      bloomPass.strength = params.bloomStrength * (0.8 + flashIntensity * 0.4) + extraBloom;
      
      step = (step + 1) % 1000;
      composer.render();
      requestAnimationFrame(animateThreeJS);
    }

    function calculateNaturalFlash(currentTime) {
      if (flashStartTime === 0 || currentTime - flashStartTime > flashDuration) {
        if (Math.random() > 0.5 || flashStartTime === 0) {
          flashState = flashState === 0 ? 1 : 0;
          flashStartTime = currentTime;
        }
      }
      const progress = Math.min((currentTime - flashStartTime) / (flashDuration / 2), 1);
      if (flashState === 0) {
        return 1 - progress * progress;
      } else {
        return progress * progress;
      }
    }

    function addTree(scene, uniforms, totalPoints, treePosition, layerIdx) {
      const vertexShader = `
      attribute float mIndex;
      attribute vec3 heartPos;   // çˆ±å¿ƒç›®æ ‡ä½ç½®
      attribute vec3 explodePos; // æ•£å¼€ç›®æ ‡ä½ç½®
      
      varying vec3 vColor;
      varying float opacity;
      
      uniform sampler2D tAudioData;
      uniform float flash;
      uniform float uHeartMix;
      uniform float uExplodeMix;

      float norm(float value, float min, float max ){
       return (value - min) / (max - min);
      }
      float lerp(float norm, float min, float max){
       return (max - min) * norm + min;
      }
      float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){
       return lerp(norm(value, sourceMin, sourceMax), destMin, destMax);
      }
      void main() {
       vColor = color;
       vec3 p = position;
       
       // ä½ç½®æ··åˆé€»è¾‘ï¼šæ ‘ -> çˆ±å¿ƒ -> çˆ†ç‚¸
       vec3 mixedPos = mix(p, heartPos, uHeartMix);
       mixedPos = mix(mixedPos, explodePos, uExplodeMix);

       vec4 mvPosition = modelViewMatrix * vec4( mixedPos, 1.0 );
       
       float baseSize = 1.0;
       
       // è§†è§‰å¢å¼ºï¼šå½“å˜å½¢æˆçˆ±å¿ƒæˆ–æ•£å¼€æ—¶ï¼Œå¤§å¹…å¢åŠ ç²’å­å¤§å°ï¼Œåˆ¶é€ æ˜Ÿç©ºæ„Ÿ
       float sizeStateBoost = 1.0 + uHeartMix * 2.0 + uExplodeMix * 4.0;
       
       float sizeMultiplier = mix(0.8, 1.2, flash) * sizeStateBoost;
       float sizeMapped = baseSize * sizeMultiplier;
       
       opacity = map(mvPosition.z , -200.0, 15.0, 0.0, 1.0);
       
       // ä¿æŒç²’å­è¿‘å¤§è¿œå°
       gl_PointSize = sizeMapped * ( 100.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;
      }
      `;
      const fragmentShader = `
      varying vec3 vColor;
      varying float opacity;
      uniform sampler2D pointTexture;
      uniform float flash;
      uniform float uExplodeMix;

      void main() {
       // çˆ†ç‚¸æ—¶å¢åŠ äº®åº¦ï¼Œæ¨¡æ‹Ÿæ˜Ÿæ˜Ÿé—ªçƒ
       float brightness = mix(0.7, 1.3, flash) + uExplodeMix * 0.8;
       vec3 color = vColor * brightness;

       float dist = length(gl_PointCoord.xy - 0.5);
       float glow = smoothstep(0.5, 0.4, dist) * 0.3;

       gl_FragColor = vec4( color + glow, opacity );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
      }
      `;
      
      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
          ...uniforms,
          pointTexture: {
            value: new THREE.TextureLoader().load(`https://assets.codepen.io/3685267/spark1.png`)
          }
        },
        vertexShader,
        fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        vertexColors: true
      });

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];
      const phases = [];
      const mIndexs = [];
      
      const heartPositions = [];
      const explodePositions = [];

      const color = new THREE.Color();
      const [px, py, pz] = treePosition; // æ ‘çš„åŸå§‹åç§»

      for (let i = 0; i < totalPoints; i++) {
        // --- 1. åœ£è¯æ ‘å½¢æ€ (ä¿æŒåŸé€»è¾‘) ---
        const t = Math.random();
        const y = map(t, 0, 1, -8, 10);
        const ang = map(t, 0, 1, 0, 6 * TAU) + TAU / 2 * (i % 2);
        const [z, x] = polar(ang, map(t, 0, 1, 5, 0));
        const modifier = map(t, 0, 1, 1, 0);
        
        // è®¡ç®—ç»å¯¹åæ ‡ï¼Œæ–¹ä¾¿ morph
        const treeX = x + rand(-0.3 * modifier, 0.3 * modifier) + px;
        const treeY = y + rand(-0.3 * modifier, 0.3 * modifier) + py;
        const treeZ = z + rand(-0.3 * modifier, 0.3 * modifier) + pz;
        
        positions.push(treeX, treeY, treeZ);

        // --- 2. çˆ±å¿ƒå½¢æ€ ---
        // çˆ±å¿ƒå…¬å¼
        const ht = Math.random() * TAU;
        // è°ƒæ•´çˆ±å¿ƒå¤§å°å’Œä½ç½®
        const scaleH = 0.4;
        const hx = 16 * Math.pow(Math.sin(ht), 3) * scaleH;
        const hy = (13 * Math.cos(ht) - 5 * Math.cos(2*ht) - 2 * Math.cos(3*ht) - Math.cos(4*ht)) * scaleH;
        // å¢åŠ ä¸€ç‚¹åšåº¦å’Œéšæœºåç§»
        const hz = (Math.random() - 0.5) * 5; 
        
        // è®©çˆ±å¿ƒæµ®åœ¨ä¸­é—´ç¨é«˜å¤„
        heartPositions.push(hx, hy + 2, hz - 10);

        // --- 3. æ•£å¼€/æ˜Ÿç©ºå½¢æ€ ---
        // åœ¨å¤§çƒä½“å†…éšæœºåˆ†å¸ƒï¼Œæ¨¡æ‹Ÿå®‡å®™èƒŒæ™¯
        const r = 60 * Math.pow(Math.random(), 0.5); // åŠå¾„å¤§ä¸€ç‚¹
        const theta = Math.random() * TAU;
        const phi = Math.acos(2 * Math.random() - 1);
        
        const ex = r * Math.sin(phi) * Math.cos(theta);
        const ey = r * Math.sin(phi) * Math.sin(theta);
        const ez = r * Math.cos(phi) - 20; // ç¨å¾®æ¨è¿œä¸€ç‚¹
        
        explodePositions.push(ex, ey, ez);

        // --- é¢œè‰² ---
        const colorSeed = Math.random();
        if (colorSeed > 0.8) {
            color.setHex(0xff0000);
        } else if (colorSeed > 0.5) {
            color.setHex(0x00ff00);
        } else {
            color.setHSL(map(i, 0, totalPoints, 0.1, 0.2), 1.0, 0.6);
        }

        colors.push(color.r, color.g, color.b);
        phases.push(rand(1000));
        sizes.push(1);
        const mIndex = map(i, 0, totalPoints, 1.0, 0.0);
        mIndexs.push(mIndex);
      }

      geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
      geometry.setAttribute("heartPos", new THREE.Float32BufferAttribute(heartPositions, 3));
      geometry.setAttribute("explodePos", new THREE.Float32BufferAttribute(explodePositions, 3));
      geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
      geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
      geometry.setAttribute("mIndex", new THREE.Float32BufferAttribute(mIndexs, 1));

      const tree = new THREE.Points(geometry, shaderMaterial);
      // ä½ç½®å·²ç»åœ¨ geometry é‡ŒåŠ ä¸Šäº†ï¼Œè¿™é‡Œå½’é›¶
      tree.position.set(0, 0, 0);
      scene.add(tree);
    }

    function addSnow(scene, uniforms) {
      const vertexShader = `
      attribute float size;
      attribute float phase;
      attribute float phaseSecondary;
      varying vec3 vColor;
      varying float opacity;
      uniform float time;
      uniform float step;
      float norm(float value, float min, float max ){ return (value - min) / (max - min); }
      float lerp(float norm, float min, float max){ return (max - min) * norm + min; }
      float map(float value, float sourceMin, float sourceMax, float destMin, float destMax){ return lerp(norm(value, sourceMin, sourceMax), destMin, destMax); }
      void main() {
       float t = time* 0.0006;
       vColor = color;
       vec3 p = position;
       p.y = map(mod(phase+step, 1000.0), 0.0, 1000.0, 25.0, -8.0);
       p.x += sin(t+phase);
       p.z += sin(t+phaseSecondary);
       opacity = map(p.z, -150.0, 15.0, 0.0, 1.0);
       vec4 mvPosition = modelViewMatrix * vec4( p, 1.0 );
       gl_PointSize = size * ( 100.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;
      }
      `;

      const fragmentShader = `
      uniform sampler2D pointTexture;
      varying vec3 vColor;
      varying float opacity;
      void main() {
       gl_FragColor = vec4( vColor, opacity );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
      }
      `;

      function createSnowSet(sprite) {
        const totalPoints = 300;
        const shaderMaterial = new THREE.ShaderMaterial({
          uniforms: {
            ...uniforms,
            pointTexture: { value: new THREE.TextureLoader().load(sprite) }
          },
          vertexShader,
          fragmentShader,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
          vertexColors: true
        });

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        const phases = [];
        const phaseSecondaries = [];
        const color = new THREE.Color();

        for (let i = 0; i < totalPoints; i++) {
          const [x, y, z] = [rand(25, -25), 0, rand(15, -150)];
          positions.push(x, y, z);
          color.setHSL(0.6, 0.1, 0.9);
          colors.push(color.r, color.g, color.b);
          phases.push(rand(1000));
          phaseSecondaries.push(rand(1000));
          sizes.push(rand(4, 2));
        }

        geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));
        geometry.setAttribute("phase", new THREE.Float32BufferAttribute(phases, 1));
        geometry.setAttribute("phaseSecondary", new THREE.Float32BufferAttribute(phaseSecondaries, 1));

        const mesh = new THREE.Points(geometry, shaderMaterial);
        scene.add(mesh);
      }

      const snowSprites = [
        "https://assets.codepen.io/3685267/snowflake1.png",
        "https://assets.codepen.io/3685267/snowflake2.png",
        "https://assets.codepen.io/3685267/snowflake3.png",
        "https://assets.codepen.io/3685267/snowflake4.png",
        "https://assets.codepen.io/3685267/snowflake5.png"
      ];

      snowSprites.forEach(sprite => {
        createSnowSet(sprite);
      });
    }

    function addPlane(scene, uniforms, totalPoints) {
      const vertexShader = `
      attribute float size;
      attribute vec3 customColor;
      varying vec3 vColor;
      uniform float flash;
      void main() {
       vColor = customColor * mix(0.95, 1.05, flash - 0.9);
       vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
       gl_PointSize = size * ( 300.0 / -mvPosition.z );
       gl_Position = projectionMatrix * mvPosition;
      }
      `;

      const fragmentShader = `
      varying vec3 vColor;
      void main() {
        float dist = length(gl_PointCoord.xy - 0.5);
        float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
        float glow = smoothstep(0.5, 0.0, dist) * 0.2;
        gl_FragColor = vec4(vColor + glow, alpha * 0.8);
      }
      `;

      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader,
        fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        vertexColors: true
      });

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];

      const color = new THREE.Color();

      for (let i = 0; i < totalPoints; i++) {
        const [x, y, z] = [rand(-50, 50), 0, rand(-150, 15)];
        positions.push(x);
        positions.push(y);
        positions.push(z);

        color.setHSL(map(i, 0, totalPoints, 0.5, 0.7), 0.9, 0.4);
        colors.push(color.r, color.g, color.b);
        sizes.push(1.5);
      }

      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3).setUsage(
          THREE.DynamicDrawUsage));

      geometry.setAttribute(
        "customColor",
        new THREE.Float32BufferAttribute(colors, 3));

      geometry.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

      const plane = new THREE.Points(geometry, shaderMaterial);
      plane.position.y = -8;
      scene.add(plane);
    }

    const map = (value, sMin, sMax, dMin, dMax) => {
      return dMin + (value - sMin) / (sMax - sMin) * (dMax - dMin);
    };

    const rand = (max, min = 0) => min + Math.random() * (max - min);
    const randInt = (max, min = 0) => Math.floor(min + Math.random() * (max - min));
    const polar = (ang, r = 1) => [r * Math.cos(ang), r * Math.sin(ang)];
    const modal = document.getElementById('start-modal');
    const btnYes = document.getElementById('btn-yes');
    const btnNo = document.getElementById('btn-no');
    const textOverlay = document.getElementById('christmas-text');
    const christmasMusic = document.getElementById('christmas-music');

    btnNo.addEventListener('mouseenter', moveButton);
    btnNo.addEventListener('click', () => {
        alert("éª—ä½ çš„ï¼Œå…¶å®ç‚¹äº†ä¹Ÿæ²¡ç”¨ï¼ğŸ„ğŸ„ğŸ„");
    });

    function moveButton() {
        if(window.innerWidth < 768) return;
        const x = Math.random() * 300 - 50;
        const y = Math.random() * 200 - 50;
        btnNo.style.transform = `translate(${x}px, ${y}px)`;
    }

    btnYes.addEventListener('click', () => {
        modal.style.opacity = '0';
        christmasMusic.play().catch(e => console.log("è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢:", e));
        
        // æ¿€æ´»éŸ³æ•ˆä¸Šä¸‹æ–‡
        AudioFX.init();

        setTimeout(() => {
            modal.style.display = 'none';
            textOverlay.classList.add('fade-in');
        }, 1000);
    });

    window.addEventListener('resize', () => {
      if (threeCamera) {
        threeCamera.aspect = window.innerWidth / window.innerHeight;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    window.addEventListener('load', init);

    // --- MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---
    function initHandTracking() {
      const videoElement = document.querySelector(".input_video");

      function onResults(results) {
        let newState = 'tree';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const landmarks = results.multiHandLandmarks[0];
          
          const isThumbUp = landmarks[4].y < landmarks[3].y;
          const isIndexUp = landmarks[8].y < landmarks[6].y;
          const isMiddleUp = landmarks[12].y < landmarks[10].y;
          const isRingUp = landmarks[16].y < landmarks[14].y;
          const isPinkyUp = landmarks[20].y < landmarks[18].y;

          const fingersUp = [isIndexUp, isMiddleUp, isRingUp, isPinkyUp].filter(Boolean).length;

          // âœ‹ æ•£å¼€ (å¼ å¼€è‡³å°‘4æ ¹æ‰‹æŒ‡)
          if (fingersUp >= 4) {
            newState = 'explode';
          } 
          // âœŒï¸ çˆ±å¿ƒ (é£ŸæŒ‡ä¸­æŒ‡ç«–èµ·ï¼Œå…¶ä»–æ”¾ä¸‹)
          else if (isIndexUp && isMiddleUp && !isRingUp && !isPinkyUp) {
            newState = 'heart';
          } 
          // âœŠ æ ‘ (æ¡æ‹³æˆ–å…¶ä»–)
          else {
            newState = 'tree';
          }
        } else {
          // æ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œä¿æŒæ ‘å½¢
          newState = 'tree';
        }

        if (newState !== lastState) {
          targetState = newState;
          // è§¦å‘å¯¹åº”éŸ³æ•ˆ
          if (newState === 'explode') AudioFX.playScatter();
          if (newState === 'heart') AudioFX.playHeart();
          if (newState === 'tree' && lastState !== 'tree') AudioFX.playTree();
          
          lastState = newState;
        }
      }

      const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }});

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      hands.onResults(onResults);

      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
      });

      camera.start();
    }
  </script>
</body>
</html>